#include <vector>
#include <fstream>
#include <string>
#include <map>
#include "ROOT/RDataFrame.hxx"
#include "TTree.h"
#include "TFile.h"
#include "TString.h"
#include "TTreeReader.h"
#include "TTreeReaderValue.h"
#include "TSystemDirectory.h"
#include "TList.h"
#include "TIterator.h"
#include "TSystem.h"

// List all .root files in a folder. Then we can read them one by one in other functions.
std::vector<TString> listFiles(TString dirName, TString dirPath, bool outputListFlag = false, TString newDirPath = "")
{
    // We use TString in this function to change these variables easily. But in
    // some constructor, we must use const char *.
    const char *ext = ".root";
    std::vector<TString> fileStringList;
    TSystemDirectory dir(dirName.Data(), dirPath.Data());
    TList *fileList = dir.GetListOfFiles();
    if (fileList)
    {
        TSystemFile *file;
        TString fileName;
        TIter next(fileList);
        while ((file = (TSystemFile *)next()))
        {
            fileName = file->GetName();
            if (!file->IsDirectory() && fileName.EndsWith(ext))
            {
                if (outputListFlag)
                    fileStringList.push_back(newDirPath + "/" + fileName);
                else
                    fileStringList.push_back(dirPath + "/" + fileName);
                //std::cout << fileName.Data() << std::endl;
            }
        }
    }
    return fileStringList;
}

// return the path name of folder in the path or return the file name with a slash in the path 
TString returnPathOrFileName(TString fileName, std::string flag)
{
    std::string fileNameString = std::string(fileName.Data());
    std::string nameString;
    if (flag == "path") nameString = fileNameString.substr(0, fileNameString.find_last_of("/"));
    else 
    {
        // file name with /
        if(flag == "file") nameString = fileNameString.substr(fileNameString.find_last_of("/"), fileNameString.length());
        else std::cout << "You input wrong option!" << std::endl;
    }
    return TString(nameString);
}

// Read the root file generated by CRAB. In my macro, the TTree in these files is not a flat tree. 
// So This function will pick a value in the file, then fill the value to a new flat TTree.
void makeFlatTree(TString oldFileName, TString newDirPath, const char *oldTreeName, const char *newTreeName, TString oldDirName='.', TString oldDirPath='.')
{
    using namespace std;
    //vector<TString> originFileList = listFiles(oldDirName, oldDirPath);
    //for (auto originFile = originFileList.cbegin(); originFile != originFileList.cend(); originFile++)
    //{
    // if you need to loop the folder, remove the oldFileName parameter. And remove comments above.
    TFile *fOrigin = new TFile(oldFileName.Data(), "READ");
    cout << "Make " << oldFileName.Data() << " to flat TTree." << endl;
    TTreeReader myReader(oldTreeName, fOrigin);
    TTreeReaderValue<vector<int>> mu1Charge = {myReader, "mu1Charge"};
    TTreeReaderValue<vector<float>> mu1Pt = {myReader, "mu1Pt"};
    TTreeReaderValue<vector<float>> mu1Eta = {myReader, "mu1Eta"};
    TTreeReaderValue<vector<float>> mu1Phi = {myReader, "mu1Phi"};
    TTreeReaderValue<vector<float>> mu1M = {myReader, "mu1M"};
    TTreeReaderValue<vector<float>> mu1Iso = {myReader, "mu1Iso"};
    TTreeReaderValue<vector<bool>> mu1Global = {myReader, "mu1Global"};
    TTreeReaderValue<vector<bool>> mu1Tight = {myReader, "mu1Tight"};
    TTreeReaderValue<vector<int>> mu2Charge = {myReader, "mu2Charge"};
    TTreeReaderValue<vector<float>> mu2Pt = {myReader, "mu2Pt"};
    TTreeReaderValue<vector<float>> mu2Eta = {myReader, "mu2Eta"};
    TTreeReaderValue<vector<float>> mu2Phi = {myReader, "mu2Phi"};
    TTreeReaderValue<vector<float>> mu2M = {myReader, "mu2M"};
    TTreeReaderValue<vector<float>> mu2Iso = {myReader, "mu2Iso"};
    TTreeReaderValue<vector<bool>> mu2Global = {myReader, "mu2Global"};
    TTreeReaderValue<vector<bool>> mu2Tight = {myReader, "mu2Tight"};
    TTreeReaderValue<vector<float>> ZPt = {myReader, "ZPt"};
    TTreeReaderValue<vector<float>> ZEta = {myReader, "ZEta"};
    TTreeReaderValue<vector<float>> ZPhi = {myReader, "ZPhi"};
    TTreeReaderValue<vector<float>> ZM = {myReader, "ZM"};
    TTreeReaderValue<vector<float>> jet1Pt = {myReader, "jet1Pt"};
    TTreeReaderValue<vector<float>> jet1Eta = {myReader, "jet1Eta"};
    TTreeReaderValue<vector<float>> jet1Phi = {myReader, "jet1Phi"};
    TTreeReaderValue<vector<float>> jet1M = {myReader, "jet1M"};
    TTreeReaderValue<vector<bool>> jet1ID = {myReader, "jet1ID"};
    TTreeReaderValue<vector<float>> jet1bTag = {myReader, "jet1bTag"};
    TTreeReaderValue<vector<float>> jet2Pt = {myReader, "jet2Pt"};
    TTreeReaderValue<vector<float>> jet2Eta = {myReader, "jet2Eta"};
    TTreeReaderValue<vector<float>> jet2Phi = {myReader, "jet2Phi"};
    TTreeReaderValue<vector<float>> jet2M = {myReader, "jet2M"};
    TTreeReaderValue<vector<bool>> jet2ID = {myReader, "jet2ID"};
    TTreeReaderValue<vector<float>> jet2bTag = {myReader, "jet2bTag"};
    TTreeReaderValue<vector<float>> HiggsPt = {myReader, "HiggsPt"};
    TTreeReaderValue<vector<float>> HiggsEta = {myReader, "HiggsEta"};
    TTreeReaderValue<vector<float>> HiggsPhi = {myReader, "HiggsPhi"};
    TTreeReaderValue<vector<float>> HiggsM = {myReader, "HiggsM"};

    int mu1Charge_, mu2Charge_;
    float mu1Pt_, mu1Eta_, mu1Phi_, mu1M_, mu1Iso_, mu2Pt_, mu2Eta_, mu2Phi_, mu2M_, mu2Iso_;
    float jet1Pt_, jet1Eta_, jet1Phi_, jet1M_, jet1bTag_, jet2Pt_, jet2Eta_, jet2Phi_, jet2M_, jet2bTag_;
    float ZPt_, ZPhi_, ZEta_, ZM_, HiggsPt_, HiggsEta_, HiggsPhi_, HiggsM_;
    bool mu1Global_, mu1Tight_, mu2Global_, mu2Tight_, jet1ID_, jet2ID_;

    vector<TTreeReaderValue<vector<float>>> floatVectors = {mu1Pt, mu1Eta, mu1Phi, mu1M, mu1Iso, mu2Pt, mu2Eta, mu2Phi, mu2M, mu2Iso,
                                                            jet1Pt, jet1Eta, jet1Phi, jet1M, jet1bTag, jet2Pt, jet2Eta, jet2Phi, jet2M, jet2bTag,
                                                            ZPt, ZEta, ZPhi, ZM, HiggsPt, HiggsEta, HiggsPhi, HiggsM};
    vector<TTreeReaderValue<vector<bool>>> boolVectors = {mu1Global, mu1Tight, mu2Global, mu2Tight, jet1ID, jet2ID};
    vector<TTreeReaderValue<vector<int>>> intVectors = {mu1Charge, mu2Charge};
    vector<float> floatNumbers = {mu1Pt_, mu1Eta_, mu1Phi_, mu1M_, mu1Iso_, mu2Pt_, mu2Eta_, mu2Phi_, mu2M_, mu2Iso_,
                                  jet1Pt_, jet1Eta_, jet1Phi_, jet1M_, jet1bTag_, jet2Pt_, jet2Eta_, jet2Phi_, jet2M_, jet2bTag_,
                                  ZPt_, ZEta_, ZPhi_, ZM_, HiggsPt_, HiggsEta_, HiggsPhi_, HiggsM_};
    vector<bool> boolNumbers = {mu1Global_, mu1Tight_, mu2Global_, mu2Tight_, jet1ID_, jet2ID_};
    vector<int> intNumbers = {mu1Charge_, mu2Charge_};
    cout << "The new file path is " << (newDirPath + returnPathOrFileName(oldFileName, "file")).Data() << endl;
    TFile *fFlat = new TFile((newDirPath + returnPathOrFileName(oldFileName, "file")).Data(), "RECREATE");
    TTree *flatZHTree = new TTree(newTreeName, newTreeName);

    const int muNumFloat = 5;
    const int jetNumFloat = 5;
    flatZHTree->SetAutoSave(0);
    flatZHTree->Branch("mu1Charge", &mu1Charge_, "mu1Charge/I");
    flatZHTree->Branch("mu1Pt", &mu1Pt_);
    flatZHTree->Branch("mu1Eta", &mu1Eta_);
    flatZHTree->Branch("mu1Phi", &mu1Phi_);
    flatZHTree->Branch("mu1M", &mu1M_);
    flatZHTree->Branch("mu1Iso", &mu1Iso_);
    flatZHTree->Branch("mu1Global", &mu1Global_, "mu1Global/O");
    flatZHTree->Branch("mu1Tight", &mu1Tight_, "mu1Tight/O");

    flatZHTree->Branch("mu2Charge", &mu2Charge_, "mu2Charge/I");
    flatZHTree->Branch("mu2Pt", &mu2Pt_);
    flatZHTree->Branch("mu2Eta", &mu2Eta_);
    flatZHTree->Branch("mu2Phi", &mu2Phi_);
    flatZHTree->Branch("mu2M", &mu2M_);
    flatZHTree->Branch("mu2Iso", &mu2Iso_);
    flatZHTree->Branch("mu2Global", &mu2Global_, "mu2Global/O");
    flatZHTree->Branch("mu2Tight", &mu2Tight_, "mu2Tight/O");

    flatZHTree->Branch("ZPt", &ZPt_);
    flatZHTree->Branch("ZEta", &ZEta_);
    flatZHTree->Branch("ZPhi", &ZPhi_);
    flatZHTree->Branch("ZM", &ZM_);

    flatZHTree->Branch("jet1Pt", &jet1Pt_);
    flatZHTree->Branch("jet1Eta", &jet1Eta_);
    flatZHTree->Branch("jet1Phi", &jet1Phi_);
    flatZHTree->Branch("jet1M", &jet1M_);
    flatZHTree->Branch("jet1bTag", &jet1bTag_);
    flatZHTree->Branch("jet1ID", &jet1ID_, "jet1ID/O");

    flatZHTree->Branch("jet2Pt", &jet2Pt_);
    flatZHTree->Branch("jet2Eta", &jet2Eta_);
    flatZHTree->Branch("jet2Phi", &jet2Phi_);
    flatZHTree->Branch("jet2M", &jet2M_);
    flatZHTree->Branch("jet2bTag", &jet2bTag_);
    flatZHTree->Branch("jet2ID", &jet2ID_, "jet2ID/O");

    flatZHTree->Branch("HiggsPt", &HiggsPt_);
    flatZHTree->Branch("HiggsEta", &HiggsEta_);
    flatZHTree->Branch("HiggsPhi", &HiggsPhi_);
    flatZHTree->Branch("HiggsM", &HiggsM_);

    while (myReader.Next())
    {
        // If some muons or jets are empty, remove the comment below
        //for (size_t i = 0; i < boolVectors.size(); i++) if (boolVectors[i]->size() == 0) myReader.Next();
        for (size_t i = 0; i < floatNumbers.size(); i++) floatNumbers[i] = floatVectors[i]->at(0);
        for (size_t i = 0; i < boolNumbers.size(); i++) boolNumbers[i] = boolVectors[i]->at(0);
        for (size_t i = 0; i < intNumbers.size(); i++) intNumbers[i] = intVectors[i]->at(0);
        //cout <<"The float numbers vector is " << floatNumbers.empty() << endl;
        //cout <<"The bool numbers vector is " << boolNumbers.empty() << endl;
        mu1Charge_ = intNumbers[0];
        mu2Charge_ = intNumbers[1];

        mu1Pt_ = floatNumbers[0];
        mu1Eta_ = floatNumbers[1];
        mu1Phi_ = floatNumbers[2];
        mu1M_ = floatNumbers[3];
        mu1Iso_ = floatNumbers[4];

        mu2Pt_ = floatNumbers[0 + muNumFloat];
        mu2Eta_ = floatNumbers[1 + muNumFloat];
        mu2Phi_ = floatNumbers[2 + muNumFloat];
        mu2M_ = floatNumbers[3 + muNumFloat];
        mu2Iso_ = floatNumbers[4 + muNumFloat];

        jet1Pt_ = floatNumbers[0 + 2 * muNumFloat];
        jet1Eta_ = floatNumbers[1 + 2 * muNumFloat];
        jet1Phi_ = floatNumbers[2 + 2 * muNumFloat];
        jet1M_ = floatNumbers[3 + 2 * muNumFloat];
        jet1bTag_ = floatNumbers[4 + 2 * muNumFloat];

        jet2Pt_ = floatNumbers[0 + 2 * muNumFloat + jetNumFloat];
        jet2Eta_ = floatNumbers[1 + 2 * muNumFloat + jetNumFloat];
        jet2Phi_ = floatNumbers[2 + 2 * muNumFloat + jetNumFloat];
        jet2M_ = floatNumbers[3 + 2 * muNumFloat + jetNumFloat];
        jet2bTag_ = floatNumbers[4 + 2 * muNumFloat + jetNumFloat];

        ZPt_ = floatNumbers[0 + 2 * muNumFloat + 2 * jetNumFloat];
        ZEta_ = floatNumbers[1 + 2 * muNumFloat + 2 * jetNumFloat];
        ZPhi_ = floatNumbers[2 + 2 * muNumFloat + 2 * jetNumFloat];
        ZM_ = floatNumbers[3 + 2 * muNumFloat + 2 * jetNumFloat];

        HiggsPt_ = floatNumbers[4 + 2 * muNumFloat + 2 * jetNumFloat];
        HiggsEta_ = floatNumbers[5 + 2 * muNumFloat + 2 * jetNumFloat];
        HiggsPhi_ = floatNumbers[6 + 2 * muNumFloat + 2 * jetNumFloat];
        HiggsM_ = floatNumbers[7 + 2 * muNumFloat + 2 * jetNumFloat];

        mu1Global_ = boolNumbers[0];
        mu1Tight_ = boolNumbers[1];
        mu2Global_ = boolNumbers[2];
        mu2Tight_ = boolNumbers[3];
        jet1ID_ = boolNumbers[4];
        jet2ID_ = boolNumbers[5];
        flatZHTree->Fill();
    }
    flatZHTree->Write();
    fFlat->Close();
    fOrigin->Close();
    //}
}

// Calculate the cutflow in a .root file.
void cutFlowCalc(TString fileName, TString pathName, ROOT::RDF::RResultPtr<ROOT::RDF::RCutFlowReport> dCutFlow)
{
    dCutFlow->Print();
    TString cutFlowFileName = returnPathOrFileName(fileName, "file");
    cutFlowFileName.Remove(cutFlowFileName.Length() - 5, cutFlowFileName.Length());
    std::ofstream cutFlowOut((pathName + cutFlowFileName + ".txt").Data());
    cutFlowOut << "Name\tAll\tPass\tEfficiency\tCumulative Eff.(%)\tJet Cum. Eff.(%)" << std::endl;
    std::vector<ULong64_t> cutFlowAllVec;
    float nEventAfterMuonCut = 0.;
    for (auto cutInfo : dCutFlow)
    {
        float jetCumEff = 0.;
        cutFlowAllVec.push_back(cutInfo.GetAll());
        if (cutInfo.GetName() == "Z mass") nEventAfterMuonCut = cutInfo.GetPass();
        if (nEventAfterMuonCut != 0) jetCumEff = (float)cutInfo.GetPass() / nEventAfterMuonCut * 100;
        cutFlowOut << cutInfo.GetName() << "\t" << cutInfo.GetAll() << "\t" << cutInfo.GetPass() << "\t"
                   << cutInfo.GetEff() << "\t" << (float)cutInfo.GetPass() / (float)cutFlowAllVec[0] * 100 << "\t"
                   << jetCumEff << std::endl;
    }
    cutFlowOut.close();
}

// Check the path is exist. If the path didn't exist, then create the path. 
// Notice: If the parent path of the input path didn't exist, the function is error.
void checkPath(TString pathName)
{
    if (gSystem->AccessPathName(pathName.Data()))
    {
        gSystem->mkdir(pathName.Data());
        std::cout << "The folder " << pathName.Data() << " is created!" << std::endl;
    }
    else
        std::cout << "The folder " << pathName.Data() << " exist!" << std::endl;
}

void cutTree(TString oldFileName, TString newDirPath, const char *oldTreeName, const char *newTreeName)
{
    using namespace std;
    TFile *fOrigin = new TFile(oldFileName.Data(), "READ");
    cout << "Cut " << oldFileName.Data() << endl;
    TTreeReader myCutReader(oldTreeName, fOrigin);
    TTreeReaderValue<vector<int>> mu1Charge = {myCutReader, "mu1Charge"};
    TTreeReaderValue<vector<float>> mu1Pt = {myCutReader, "mu1Pt"};
    TTreeReaderValue<vector<float>> mu1Eta = {myCutReader, "mu1Eta"};
    TTreeReaderValue<vector<float>> mu1Phi = {myCutReader, "mu1Phi"};
    TTreeReaderValue<vector<float>> mu1M = {myCutReader, "mu1M"};
    TTreeReaderValue<vector<float>> mu1Iso = {myCutReader, "mu1Iso"};
    TTreeReaderValue<vector<bool>> mu1Global = {myCutReader, "mu1Global"};
    TTreeReaderValue<vector<bool>> mu1Tight = {myCutReader, "mu1Tight"};
    TTreeReaderValue<vector<int>> mu2Charge = {myCutReader, "mu2Charge"};
    TTreeReaderValue<vector<float>> mu2Pt = {myCutReader, "mu2Pt"};
    TTreeReaderValue<vector<float>> mu2Eta = {myCutReader, "mu2Eta"};
    TTreeReaderValue<vector<float>> mu2Phi = {myCutReader, "mu2Phi"};
    TTreeReaderValue<vector<float>> mu2M = {myCutReader, "mu2M"};
    TTreeReaderValue<vector<float>> mu2Iso = {myCutReader, "mu2Iso"};
    TTreeReaderValue<vector<bool>> mu2Global = {myCutReader, "mu2Global"};
    TTreeReaderValue<vector<bool>> mu2Tight = {myCutReader, "mu2Tight"};
    TTreeReaderValue<vector<float>> ZPt = {myCutReader, "ZPt"};
    TTreeReaderValue<vector<float>> ZEta = {myCutReader, "ZEta"};
    TTreeReaderValue<vector<float>> ZPhi = {myCutReader, "ZPhi"};
    TTreeReaderValue<vector<float>> ZM = {myCutReader, "ZM"};
    TTreeReaderValue<vector<float>> jet1Pt = {myCutReader, "jet1Pt"};
    TTreeReaderValue<vector<float>> jet1Eta = {myCutReader, "jet1Eta"};
    TTreeReaderValue<vector<float>> jet1Phi = {myCutReader, "jet1Phi"};
    TTreeReaderValue<vector<float>> jet1M = {myCutReader, "jet1M"};
    TTreeReaderValue<vector<bool>> jet1ID = {myCutReader, "jet1ID"};
    TTreeReaderValue<vector<float>> jet1bTag = {myCutReader, "jet1bTag"};
    TTreeReaderValue<vector<float>> jet2Pt = {myCutReader, "jet2Pt"};
    TTreeReaderValue<vector<float>> jet2Eta = {myCutReader, "jet2Eta"};
    TTreeReaderValue<vector<float>> jet2Phi = {myCutReader, "jet2Phi"};
    TTreeReaderValue<vector<float>> jet2M = {myCutReader, "jet2M"};
    TTreeReaderValue<vector<bool>> jet2ID = {myCutReader, "jet2ID"};
    TTreeReaderValue<vector<float>> jet2bTag = {myCutReader, "jet2bTag"};
    TTreeReaderValue<vector<float>> HiggsPt = {myCutReader, "HiggsPt"};
    TTreeReaderValue<vector<float>> HiggsEta = {myCutReader, "HiggsEta"};
    TTreeReaderValue<vector<float>> HiggsPhi = {myCutReader, "HiggsPhi"};
    TTreeReaderValue<vector<float>> HiggsM = {myCutReader, "HiggsM"};
    
    TFile *fCut = new TFile((newDirPath + returnPathOrFileName(oldFileName, "file")).Data(), "RECREATE");
    TTree *cutZHTree = new TTree(newTreeName, newTreeName);

    int mu1Charge_, mu2Charge_;
    float mu1Pt_, mu1Eta_, mu1Phi_, mu1M_, mu1Iso_, mu2Pt_, mu2Eta_, mu2Phi_, mu2M_, mu2Iso_;
    float jet1Pt_, jet1Eta_, jet1Phi_, jet1M_, jet1bTag_, jet2Pt_, jet2Eta_, jet2Phi_, jet2M_, jet2bTag_;
    float ZPt_, ZPhi_, ZEta_, ZM_, HiggsPt_, HiggsEta_, HiggsPhi_, HiggsM_;
    bool mu1Global_, mu1Tight_, mu2Global_, mu2Tight_, jet1ID_, jet2ID_;
    cutZHTree->SetAutoSave(0);
    cutZHTree->Branch("mu1Charge", &mu1Charge_, "mu1Charge/I");
    cutZHTree->Branch("mu1Pt", &mu1Pt_);
    cutZHTree->Branch("mu1Eta", &mu1Eta_);
    cutZHTree->Branch("mu1Phi", &mu1Phi_);
    cutZHTree->Branch("mu1M", &mu1M_);
    cutZHTree->Branch("mu1Iso", &mu1Iso_);
    cutZHTree->Branch("mu1Global", &mu1Global_, "mu1Global/O");
    cutZHTree->Branch("mu1Tight", &mu1Tight_, "mu1Tight/O");

    cutZHTree->Branch("mu2Charge", &mu2Charge_, "mu2Charge/I");
    cutZHTree->Branch("mu2Pt", &mu2Pt_);
    cutZHTree->Branch("mu2Eta", &mu2Eta_);
    cutZHTree->Branch("mu2Phi", &mu2Phi_);
    cutZHTree->Branch("mu2M", &mu2M_);
    cutZHTree->Branch("mu2Iso", &mu2Iso_);
    cutZHTree->Branch("mu2Global", &mu2Global_, "mu2Global/O");
    cutZHTree->Branch("mu2Tight", &mu2Tight_, "mu2Tight/O");

    cutZHTree->Branch("ZPt", &ZPt_);
    cutZHTree->Branch("ZEta", &ZEta_);
    cutZHTree->Branch("ZPhi", &ZPhi_);
    cutZHTree->Branch("ZM", &ZM_);

    cutZHTree->Branch("jet1Pt", &jet1Pt_);
    cutZHTree->Branch("jet1Eta", &jet1Eta_);
    cutZHTree->Branch("jet1Phi", &jet1Phi_);
    cutZHTree->Branch("jet1M", &jet1M_);
    cutZHTree->Branch("jet1bTag", &jet1bTag_);
    cutZHTree->Branch("jet1ID", &jet1ID_, "jet1ID/O");

    cutZHTree->Branch("jet2Pt", &jet2Pt_);
    cutZHTree->Branch("jet2Eta", &jet2Eta_);
    cutZHTree->Branch("jet2Phi", &jet2Phi_);
    cutZHTree->Branch("jet2M", &jet2M_);
    cutZHTree->Branch("jet2bTag", &jet2bTag_);
    cutZHTree->Branch("jet2ID", &jet2ID_, "jet2ID/O");

    cutZHTree->Branch("HiggsPt", &HiggsPt_);
    cutZHTree->Branch("HiggsEta", &HiggsEta_);
    cutZHTree->Branch("HiggsPhi", &HiggsPhi_);
    cutZHTree->Branch("HiggsM", &HiggsM_);

    while (myCutReader.Next())
    {
        map<string, float> eachMuPair, eachJetPair;
        vector<map<string, float>> oldMuPair, cutMuPair;
        vector<map<string, float>> oldJetPair, cutJetPair;
        for (size_t i = 0; i < mu1Pt->size(); i++)
        {
            eachMuPair["mu1Charge"] = mu1Charge->at(i);
            eachMuPair["mu1Pt"] = mu1Pt->at(i);
            eachMuPair["mu1Eta"] = mu1Eta->at(i);
            eachMuPair["mu1Phi"] = mu1Phi->at(i);
            eachMuPair["mu1M"] = mu1M->at(i);
            eachMuPair["mu1Tight"] = mu1Tight->at(i);
            eachMuPair["mu1Global"] = mu1Global->at(i);
            eachMuPair["mu1Charge"] = mu1Charge->at(i);
            eachMuPair["mu2Pt"] = mu2Pt->at(i);
            eachMuPair["mu2Eta"] = mu2Eta->at(i);
            eachMuPair["mu2Phi"] = mu2Phi->at(i);
            eachMuPair["mu2M"] = mu2M->at(i);
            eachMuPair["mu2Tight"] = mu2Tight->at(i);
            eachMuPair["mu2Global"] = mu2Global->at(i);
            eachMuPair["ZPt"] = ZPt->at(i);
            eachMuPair["ZEta"] = ZEta->at(i);
            eachMuPair["ZPhi"] = ZPhi->at(i);
            eachMuPair["ZM"] = ZM->at(i);
            oldMuPair.push_back(eachMuPair);
        }
        for (size_t i = 0; i < jet1Pt->size(); i++)
        {
            eachJetPair["jet1Pt"] = jet1Pt->at(i);
            eachJetPair["jet1Eta"] = jet1Eta->at(i);
            eachJetPair["jet1Phi"] = jet1Phi->at(i);
            eachJetPair["jet1M"] = jet1M->at(i);
            eachJetPair["jet1bTag"] = jet1bTag->at(i);
            eachJetPair["jet1ID"] = jet1ID->at(i);
            eachJetPair["jet2Pt"] = jet2Pt->at(i);
            eachJetPair["jet2Eta"] = jet2Eta->at(i);
            eachJetPair["jet2Phi"] = jet2Phi->at(i);
            eachJetPair["jet2M"] = jet2M->at(i);
            eachJetPair["jet2bTag"] = jet2bTag->at(i);
            eachJetPair["jet2ID"] = jet2ID->at(i);
            eachJetPair["HiggsPt"] = HiggsPt->at(i);
            eachJetPair["HiggsEta"] = HiggsEta->at(i);
            eachJetPair["HiggsPhi"] = HiggsPhi->at(i);
            eachJetPair["HiggsM"] = HiggsM->at(i);
            oldJetPair.push_back(eachJetPair);
        }
        for (auto muPair : oldMuPair)
        {
            if (!(muPair["mu1Pt"] > 25 && muPair["mu2Pt"] > 15)) continue;
            if (!(muPair["mu1Tight"] == 1 && muPair["mu2Tight"] == 1)) continue;
            if (!(muPair["mu1Eta"] < 2.4 && muPair["mu2Eta"] < 2.4)) continue;
            if (!(muPair["mu1Iso"] < 0.4 && muPair["mu2Iso"] < 0.4)) continue;
            if (!(muPair["ZM"] >= 75 && muPair["ZM"] <= 105)) continue;
            cutMuPair.push_back(muPair);
        }
        for (auto jetPair : oldJetPair)
        {
            if (!(jetPair["jet1Pt"] > 20 && jetPair["jet2Pt"] > 20)) continue;
            if (!(jetPair["jet1bTag"] > 0.4184 && jetPair["jet2bTag"] > 0.4184)) continue;
            if (!(jetPair["jet1ID"] == 1 && jetPair["jet2ID"] == 1)) continue;
            if (!(jetPair["HiggsM"] >= 50 && jetPair["HiggsM"] <= 200)) continue;
            cutJetPair.push_back(jetPair);
        }
        if (cutMuPair.size() > 0 && cutJetPair.size() > 0)
        {
            mu1Charge_ = (int)cutMuPair[0]["mu1Charge"];
            mu2Charge_ = (int)cutMuPair[0]["mu2Charge"];

            mu1Pt_ = cutMuPair[0]["mu1Pt"];
            mu1Eta_ = cutMuPair[0]["mu1Eta"];
            mu1Phi_ = cutMuPair[0]["mu1Phi"];
            mu1M_ = cutMuPair[0]["mu1M"];
            mu1Iso_ = cutMuPair[0]["mu1Iso"];

            mu2Pt_ = cutMuPair[0]["mu2Pt"];
            mu2Eta_ = cutMuPair[0]["mu2Eta"];
            mu2Phi_ = cutMuPair[0]["mu2Phi"];
            mu2M_ = cutMuPair[0]["mu2M"];
            mu2Iso_ = cutMuPair[0]["mu1Iso"];

            jet1Pt_ = cutJetPair[0]["jet1Pt"];
            jet1Eta_ = cutJetPair[0]["jet1Eta"];
            jet1Phi_ = cutJetPair[0]["jet1Phi"];
            jet1M_ = cutJetPair[0]["jet1M"];
            jet1bTag_ = cutJetPair[0]["jet1bTag"];

            jet2Pt_ = cutJetPair[0]["jet2Pt"];
            jet2Eta_ = cutJetPair[0]["jet2Eta"];
            jet2Phi_ = cutJetPair[0]["jet2Phi"];
            jet2M_ = cutJetPair[0]["jet2M"];
            jet2bTag_ = cutJetPair[0]["jet1bTag"];

            ZPt_ = cutMuPair[0]["ZPt"];
            ZEta_ = cutMuPair[0]["ZEta"];
            ZPhi_ = cutMuPair[0]["ZPhi"];
            ZM_ = cutMuPair[0]["ZM"];

            HiggsPt_ = cutJetPair[0]["HiggsPt"];
            HiggsEta_ = cutJetPair[0]["HiggsEta"];
            HiggsPhi_ = cutJetPair[0]["HiggsPhi"];
            HiggsM_ = cutJetPair[0]["HiggsM"];

            mu1Global_ = (bool)cutMuPair[0]["mu1Global"];
            mu1Tight_ = (bool)cutMuPair[0]["mu1Tight"];
            mu2Global_ = (bool)cutMuPair[0]["mu2Global"];
            mu2Tight_ = (bool)cutMuPair[0]["mu2Tight"];
            jet1ID_ = (bool)cutJetPair[0]["jet1ID"];
            jet2ID_ = (bool)cutJetPair[0]["jet2ID"];
            cutZHTree->Fill();
        }
        oldMuPair.clear();
        oldJetPair.clear();
        cutMuPair.clear();
        cutJetPair.clear();
        eachMuPair.clear();
        eachJetPair.clear();
    }
    cutZHTree->Write();
    fCut->Close();
    fOrigin->Close();
}


// main function
int ntupleReducer(TString fileName, TString savePath)
{
    ROOT::IsImplicitMTEnabled(); // open multi-process (For HTCondor, comment it!)
    auto oldTreeName = "demo/ZHCollection"; // keep same with the name of TTree in the source
    auto newTreeName = "ZHCandidates";

    // create the workspace
    TString oldDirName = "Samples";
    TString oldPathName = returnPathOrFileName(fileName, "path");
    TString flatPathName = savePath + "/FlatTrees";
    TString jetCutFlowPathName = savePath + "/JetCutFlow";
    checkPath(savePath);
    checkPath(flatPathName);
    TString flatFileName = flatPathName + returnPathOrFileName(fileName, "file");
    cutTree(fileName, flatPathName, oldTreeName, newTreeName);
    return 0;
}
